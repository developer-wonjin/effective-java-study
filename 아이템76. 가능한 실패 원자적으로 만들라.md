# 아이템76. 가능한 실패 원자적으로 만들라

# 1. 용어정리
- `실패원자적`이란?
> 호출된 메서드가 실패하더라도(예외가 발생하더라도) 메서드가 소속된 객체의 상태를 메서도 호출전 상태로 유지해야한다.

<br>

# 2. 실패원자적으로 코딩하는 방법
## 2.1. 불변객체를 이용할 것.
- 불변객체는 태생적으로 `실패원자적`이다. 애초에 수정될 일이 없음.
- 즉, 기존객체가 불완전해 지는 경우가 없음.
- 생성시점이후로 절대 변하지 않음.

<br>

## 2.2. 가변객체일 경우 해법
메서드 작업내용 최상단에서 매개변수의 유효성을 검사할 것
- 객체의 상태를 변경하기 앞서 잠재적 예외가능성을 제거
- ```java
    public Stack{
        ...
        public Object pop(){
            //if(size == 0)
            //    throw new EmptyStackException();
            Object result = elements[--size];
            elements[size] = null;
            return result;
        }
        ...
    }
    ```
- 위 코드에서 주석부분이 없다면 pop()메소드의 `Object result = elements[--size]` 실행후 예외가 발생한 뒤 size는 불안정한 상태를 유지
- 상황에 어울리지 않는 추상화수준
  - `OutOfBoundsException`예외보다  `EmptyStackException`예외가 적절함.

<br>

## 2.3. 실패할 가능성이 있는 코드의 위치 조절
- `실패할 가능성이 있는 코드` 는 앞에 배치(2.2와 비슷함)
- `객체상태를 바꿀 코드`는 뒤에 배치

<br>

## 2.4. 별도의 저장공간에 임시복사본을 활용하는 방법
- List객체의 각 요소를 배열에 저장
- 이후, 정렬작업시 배열을 이용
- 정렬실패시 List객체의 실패원자성(sort메소드 실행전 상태)을 보장할 수 있음.

<br>

## 2.5. 복구코드를 작성하여 작업 전 상태로 되돌리는 방법
- 디스크기반의 내구성을 보장해야 하는 자료구조에 쓰임.

<br>

# 3. 실패원자성을 달성할 수 없는 케이스
- 멀티쓰레드의 비동기적 작업으로 동시에(Concurrent) 변경(Modify)할 경우
  - 한 쪽 쓰레드에서 코드상단에서 우선적으로 ConcurrentModificationException이 발생했다고 하더라도 
  - 다른 쓰레드에서 객체의 상태를 바꿀 가능성이 있을것 같다.

# [정리]
예외가 발생하면 객체의 상태가 예외발생 전으로 되돌려놔야한다는 것을 잊지말자.